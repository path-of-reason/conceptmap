### 계획: 노트 생성을 위한 백엔드 API 구현

**목표**: 프런트엔드에서 사용자가 새 노트를 작성하고 저장할 때, 이를 처리하는 백엔드 Tauri 커맨드를 구현합니다. 이 커맨드는 노트 데이터를 받아 마크다운 파일을 생성하고, KuzuDB에 노드와 관계를 저장하는 역할을 합니다.

- [x] **1. `create_note` Tauri 커맨드 정의**
    - [x] `src-tauri/src/db/commands.rs` (또는 새 파일)에 `create_note`라는 `#[tauri::command]`를 추가합니다.
    - [x] 이 커맨드는 프런트엔드로부터 `title: String`, `content: String`, `parent_uuid: Option<String>`를 인자로 받습니다.

- [x] **2. 노트 데이터 생성 및 파일 저장 로직**
    - [x] `create_note` 커맨드 내에서 `Note` 객체를 생성합니다.
    - [x] `uuid::Uuid::new_v4()`로 고유 ID를, `chrono::Utc::now()`로 타임스탬프를 설정합니다.
    - [x] `lexorank` crate를 사용하여 정렬을 위한 `rank` 값을 계산합니다. (초기 구현에서는 부모의 마지막 자식으로 추가하는 간단한 로직을 사용합니다.)
    - [x] 생성된 `Note` 데이터를 기반으로, 현재 Vault 경로에 `{uuid}.md` 형식의 마크다운 파일을 생성합니다. 파일에는 YAML Frontmatter(`uuid`, `title`, `rank` 등)와 본문(`content`)이 포함되어야 합니다.

- [x] **3. KuzuDB 노드 및 관계 생성 로직**
    - [x] 파일 저장 후, KuzuDB에 `Note` 노드를 추가하는 `CREATE` 쿼리를 실행합니다.
    - [x] `parent_uuid`가 인자로 주어진 경우, `MATCH` 쿼리로 부모와 자식 노드를 찾아 `(자식)-[:CHILD_OF]->(부모)` 관계를 생성합니다.
    - [x] (선택적 심화) 동일 부모를 가진 다른 자식 노드들을 찾아, `rank` 순서에 맞게 `:NEXT` 관계를 설정하거나 업데이트하는 로직을 추가합니다.

- [x] **4. 커맨드 반환 값 처리**
    - [x] `create_note` 커맨드가 성공적으로 완료되면, 생성된 `Note` 객체 전체(계산된 `uuid`, `rank`, `created_at` 등 포함)를 프런트엔드에 반환하도록 설정합니다.
    - [x] 파일 저장이나 DB 쿼리 등 각 단계에서 발생할 수 있는 에러를 `Result<Note, String>`으로 처리하여 프런트엔드에 명확한 실패 원인을 전달합니다.

- [x] **5. 온톨로지 문서 업데이트**
    - [x] `db/commands.rs` 등 수정된 파일에 대한 온톨로지 문서를 작성하거나 업데이트합니다.

***

# 🟩 **계획서와 현재 코드 구조의 적합성 검토**

***

## 1. **Tauri 커맨드 및 파일 구조**

- **계획:**  
  - `src-tauri/src/db/commands.rs`에 커맨드 정의
- **지금:**  
  - 실제 커맨드/핸들러 함수 파일 위치는 달라도,  
    Tauri에서 `#[tauri::command]` 어노테이션 함수로 호출할 수 있게 구조화 가능  
    (`kuzudb/commands.rs` 또는 메인 tauri 커맨드 모듈 등)
- **문제 없음:**  
  - 파일 위치/모듈명 등만 실제 프젝 구조 맞춰 조정 가능

***

## 2. **노트 객체 생성 및 파일 저장**

- **계획:**  
  - `Note` 객체를 만들고, UUID/timestamp/lexorank 생성  
  - 노트 내용을 마크다운(YAML frontmatter+본문)으로 파일화
- **지금:**  
  - Note 모델, Uuid/chrono/lexorank 활용 가능  
  - Rust 표준 file IO로 마크다운 저장 코드를 추가하면 계획과 동일하게 구현 가능

***

## 3. **DB 노드 및 관계 생성**

- **계획:**  
  - 노트 파일 저장 후, KuzuDB에 CREATE 쿼리  
  - parent_uuid 있으면 ChildOf/NEXT 관계 동적 생성 쿼리
- **지금:**  
  - KuzuDB에 exec_query, insert_note 등으로 실현 가능  
  - 관계 생성 쿼리(ChildOf, Next)도 바로 추가 구현 가능  
- Tauri 커맨드 또는 비즈니스 로직 함수 내부에서 그대로 쿼리 호출하면 구조와 기능 전부 만족

***

## 4. **API 반환 및 오류처리**

- **계획:**  
  - 커맨드에서 Note 전체(생성 값 포함) 반환,  
  - 에러는 `Result<Note, String>`으로 직관적 전달
- **지금:**  
  - Rust Tauri 커맨드에서 그대로 `Result<Note, String>` 타입 반환 구현 쉬움  
  - 파일저장/쿼리/관계실패 모두 String 변환해서 프론트로 직관적 전송 가능

***

## 5. **온톨로지 문서화**

- **계획:**  
  - 파일별 목적/역할 주석, 문서화
- **지금:**  
  - 각 파일/module에 적절한 docstring/주석/README 추가만 하면 바로 완료

***

# ⚡️ **결론**

- **실제 Data Flow, 구조, 준비된 코드가 모두 계획의 목적과 일치하거나 바로 확장 가능**  
- **파일/모듈 위치나 실제 네이밍만 사소하게 다르고, 기능·API·에러처리·리턴타입 등 완전 호환**

***

# ✅ **이제 곧바로 진행/작성 가능한 점**

- create_note Tauri 커맨드(`#[tauri::command]`) 함수 작성
- Note/파일 저장, uuid/lexorank 생성, 관계 쿼리 등 구현
- 실질적으로 모든 부분에서 계획과 준비된 코드가 정확히 맞물립니다.

***

**즉, 약간의 파일 위치/네이밍만 맞추면  
당장 Tauri 커맨드/Note 생성/DB·MD파일 저장/관계 쿼리/정렬 대응에  
근본적 문제 없이 바로 적용 가능합니다!**

진짜 코드 예시나 다음 단계 명령, 상세 구현이 필요하다면  
그대로 안내드릴 수 있습니다.  
구현에 막히는 부분, 네이밍/구조 최종 결정 필요하면 구체적으로 말씀해 주세요!

### 계획: 노트 이동 (Drag & Drop) 기능 구현

**목표**: 사용자가 드래그 앤 드롭을 통해 특정 노트를 다른 노트의 자식으로 이동시켜, 노트의 계층 구조를 동적으로 변경할 수 있는 기능을 구현합니다.

- [ ] **1. 백엔드 `move_note` 커맨드 구현**
    - [ ] `db/commands.rs`에 `move_note` Tauri 커맨드를 추가합니다. 인자로는 `moved_note_uuid: String`와 `new_parent_uuid: String`를 받습니다.
    - [ ] **관계 및 데이터 업데이트 로직**:
        - [ ] **(1) 기존 관계 해제**: `moved_note`의 이전 형제와 다음 형제를 찾아, 둘을 `:NEXT` 관계로 직접 연결하여 끊어진 고리를 메웁니다.
        - [ ] **(2) 부모 변경**: `moved_note`의 `parent_uuid` 필드를 `new_parent_uuid`로 업데이트합니다.
        - [ ] **(3) Rank 재계산**: `moved_note`가 `new_parent_uuid`의 마지막 자식이 되도록 새로운 `rank` 값을 계산하여 업데이트합니다.
        - [ ] **(4) 신규 관계 연결**: `new_parent_uuid`의 기존 마지막 자식과 `moved_note`를 `:NEXT` 관계로 연결합니다.
    - [ ] 성공적으로 완료되면 `Result<(), String>`을 반환합니다. (프런트엔드는 전체 목록을 새로고침할 것이므로 복잡한 데이터 반환은 불필요)

- [ ] **2. 프런트엔드 드래그 앤 드롭 로직 확장**
    - [ ] `NoteListView.svelte`의 `dndzone` 로직을 확장하여, 노트 아이템의 중앙 영역에 드롭하는 것을 '부모 변경' 액션으로 감지하도록 설정합니다. (상/하단 영역은 '순서 변경')
    - [ ] 드래그 중인 아이템이 다른 아이템 위에 올라갔을 때, 부모가 변경될 것임을 알려주는 시각적 피드백(예: 타겟 노트 하이라이팅)을 추가합니다.

- [ ] **3. 프런트엔드 드롭 이벤트 처리 및 API 연동**
    - [ ] 드롭 이벤트 핸들러에서 '순서 변경'과 '부모 변경' 액션을 구분합니다.
    - [ ] '부모 변경'으로 감지되면, `move_note` 커맨드를 `moved_note_uuid`와 `new_parent_uuid`와 함께 호출합니다.
    - [ ] **UI 업데이트 전략**: 노트 이동은 다수 노트의 `level`과 `displayId`에 영향을 주므로, 로컬 상태를 수동으로 수정하는 대신, API 호출 성공 시 `notes.svelte.ts`의 `fetchAllNotes` 함수를 다시 호출하여 전체 목록을 서버로부터 새로고침하는 방식을 사용합니다. 이는 더 단순하고 안정적인 방법입니다.

- [ ] **4. API 및 스토어 로직 추가**
    - [ ] `src/lib/tauri/note.ts`와 `src/lib/store/notes.svelte.ts`에 `moveNote` 함수를 각각 추가하여 UI와 백엔드를 연결합니다.

- [ ] **5. 온톨로지 문서 업데이트**
    - [ ] `NoteListView.svelte` 등 노트 이동 로직이 추가되면서 수정된 파일들의 온톨로지 문서를 업데이트합니다.
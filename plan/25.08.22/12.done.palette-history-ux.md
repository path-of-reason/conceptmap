# 작업 완료 보고서: 팔레트(Palette) 기능 개선

**목표**: `Palette.svelte` 컴포넌트의 사용자 경험을 개선하기 위해, 최근에 사용한 커맨드를 리스트 최상단에 정렬하고 시각적으로 "최근 사용" 뱃지를 표시했습니다.

---

## 1. 데이터 처리 로직 수정: 정렬 및 'isRecent' 플래그 추가

- **변경 이유**: 사용자가 최근에 사용한 명령에 더 쉽게 접근하고, UI 상에서 명확하게 인지할 수 있도록 하기 위해 데이터 처리 로직을 개선했습니다.
- **구현 내용**:
    - `filteredCommands`를 대체하는 새로운 `$derived` 상태 변수 `displayList`를 도입했습니다.
    - `displayList`는 `API.commandHistory`를 참조하여 최근 사용 커맨드 2개를 리스트 최상단으로 가져오도록 정렬 로직을 구현했습니다.
    - 퍼지 검색 필터링은 이 정렬된 리스트를 기반으로 동작하도록 수정했습니다.
    - 최종적으로 각 리스트 아이템에 `{ command, matches, isRecent }` 객체를 생성하여, 최근 사용 여부를 `isRecent` 플래그로 관리하도록 했습니다.
- **코드 변경 (`src/layout/views/modal/Palette.svelte` - script)**:

```svelte
<script lang="ts">
  import { API } from "$lib/store/api";
  import type { Command } from "$lib/types";

  let searchQuery = $state("");
  let highlightedIndex = $state(-1);
  let searchInput: HTMLInputElement; // Declare searchInput
  let listElement: HTMLUListElement; // Declare listElement

  const allCommands = $derived(Array.from(API.command.commandMap.values()));
  const commandHistory = $derived(API.commandHistory.getHistory());

  const fuzzyMatch = (pattern: string, text: string) => {
    const patternLower = pattern.toLowerCase();
    const textLower = text.toLowerCase();
    let patternIdx = 0;
    const matches: number[] = [];

    for (let textIdx = 0; textIdx < textLower.length; textIdx++) {
      if (
        patternIdx < patternLower.length &&
        textLower[textIdx] === patternLower[patternIdx]
      ) {
        matches.push(textIdx);
        patternIdx++;
      }
    }
    return patternIdx === patternLower.length ? matches : null;
  };

  const displayList = $derived.by(() => {
    const recentKeys = commandHistory.slice(0, 2);

    const sortedCommands = [...allCommands].sort((a, b) => {
      const aIsRecent = recentKeys.includes(a.key);
      const bIsRecent = recentKeys.includes(b.key);

      if (aIsRecent && !bIsRecent) return -1;
      if (!aIsRecent && bIsRecent) return 1;
      if (aIsRecent && bIsRecent) {
        return recentKeys.indexOf(a.key) - recentKeys.indexOf(b.key);
      }
      return a.description.localeCompare(b.description);
    });

    if (!searchQuery) {
      return sortedCommands.map((cmd) => ({
        command: cmd,
        matches: null,
        isRecent: recentKeys.includes(cmd.key),
      }));
    }

    const results: { command: Command; matches: number[] | null; isRecent: boolean }[] = [];
    for (const cmd of sortedCommands) {
      const matches = fuzzyMatch(searchQuery, cmd.description);
      if (matches) {
        results.push({
          command: cmd,
          matches,
          isRecent: recentKeys.includes(cmd.key),
        });
      }
    }
    return results;
  });

  const highlightText = (text: string, matches: number[] | null) => {
    if (!matches || matches.length === 0) {
      return text;
    }
    let highlighted = "";
    let lastIdx = 0;
    for (const matchIdx of matches) {
      highlighted += text.substring(lastIdx, matchIdx);
      highlighted += `<strong class="text-yellow-300">${text[matchIdx]}</strong>`;
      lastIdx = matchIdx + 1;
    }
    highlighted += text.substring(lastIdx);
    return highlighted;
  };

  const executeAndClose = (commandKey: string) => {
    API.command.executeCommand(commandKey);
    API.commandHistory.addCommand(commandKey);
    API.modal.closeModal();
  };

  const handleKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        highlightedIndex =
          (highlightedIndex - 1 + displayList.length) %
          displayList.length;
        break;
      case "ArrowDown":
        e.preventDefault();
        highlightedIndex = (highlightedIndex + 1) % displayList.length;
        break;
      case "Enter":
        e.preventDefault();
        if (highlightedIndex >= 0 && displayList[highlightedIndex]) {
          executeAndClose(displayList[highlightedIndex].command.key);
        }
        break;
      case "Escape":
        e.preventDefault();
        API.modal.closeModal();
        break;
    }
  };

  // Reset highlightedIndex when displayList changes
  $effect(() => {
    highlightedIndex = displayList.length > 0 ? 0 : -1;
  });

  // Auto-scroll to highlighted item
  $effect(() => {
    if (highlightedIndex >= 0 && listElement) {
      const selectedItem = listElement.children[
        highlightedIndex
      ] as HTMLLIElement;
      if (selectedItem) {
        selectedItem.scrollIntoView({ block: "nearest" });
      }
    }
  });

  // Export focusInput function
  export function focusInput() {
    searchInput.focus();
  }
</script>
```

## 2. UI 템플릿 업데이트: '최근 사용' 뱃지 추가

- **변경 이유**: 데이터 로직에서 추가된 `isRecent` 플래그를 활용하여, UI 상에서 최근 사용 항목을 시각적으로 명확하게 구분하기 위해 템플릿을 수정했습니다.
- **구현 내용**:
    - `{#each}` 블록이 새로운 `displayList`를 순회하도록 변경했습니다.
    - `{#if isRecent}` 블록을 추가하여, 해당 플래그가 `true`인 경우에만 "최근 사용" 뱃지가 렌더링되도록 했습니다.
    - `flex`와 `justify-between` 스타일을 사용하여 뱃지가 항목의 오른쪽에 위치하도록 정렬했습니다.
- **코드 변경 (`src/layout/views/modal/Palette.svelte` - template)**:

```svelte
<div
  class={[
    "w-[500px] max-w-[90vw]",
    "bg-gradient-to-r from-zinc-900 via-slate-950 to-black border border-zinc-700 rounded-lg",
    "p-4 z-1000 text-gray-100",
  ]}
  role="dialog"
  aria-modal="true"
>
  <input
    type="text"
    placeholder="Search commands..."
    class={[
      "w-full py-2 px-2.5 mb-3",
      "bg-zinc-800 border border-zinc-700 rounded-md text-gray-100",
      "box-border focus:outline-none focus:ring-2 focus:ring-zinc-500",
    ]}
    bind:value={searchQuery}
    onkeydown={handleKeyDown}
    bind:this={searchInput}
  />
  <ul
    bind:this={listElement}
    class="list-none p-0 m-0 max-h-[300px] h-fit overflow-y-auto transition"
  >
    {#each displayList as { command, matches, isRecent }, index (command.key)}
      <li
        class={[
          "py-2 px-3 cursor-pointer rounded-md text-gray-100",
          index === highlightedIndex
            ? "bg-zinc-600 text-white"
            : "bg-transparent",
          "hover:bg-slate-700",
        ]}
      >
        <button
          class="h-full w-full text-left flex justify-between items-center"
          onmousedown={(e) => e.preventDefault()}
          onclick={() => executeAndClose(command.key)}
        >
          <span>
            {@html highlightText(command.description, matches)}
          </span>
          {#if isRecent}
            <span class="text-xs text-gray-400 bg-zinc-700 px-1.5 py-0.5 rounded-md">
              최근 사용
            </span>
          {/if}
        </button>
      </li>
    {:else}
      <li class="py-2 px-3 text-gray-300">No commands found.</li>
    {/each}
  </ul>
</div>
```

## 3. 기능 검증

- **검증 내용**: 코드 리뷰를 통해 모든 기능적 요구사항이 로직에 올바르게 반영되었음을 확인했습니다.
    - 팔레트 오픈 시 최근 사용 커맨드가 최상단에 정렬됩니다.
    - 해당 항목에 "최근 사용" 뱃지가 정상적으로 표시됩니다.
    - 검색 기능 및 키보드/마우스 상호작용이 새로운 데이터 구조(`displayList`)와 연동되어 올바르게 동작합니다.

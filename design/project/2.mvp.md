## 1️⃣ **첫 번째 할 일: 백엔드 Minimal Core**

**필수 구현 리스트:**
- [ ] 마크다운 파일 ingest (폴더 전수 스캔 → 파일명, 본문, meta 파싱)
- [ ] 노트 데이터 모델(필수: persistentId, title, content, parent, next 등)
- [ ] KuzuDB 그래프 저장(노드/관계 생성, :NEXT/:CHILD_OF 등)
- [ ] 기본 노트 CRUD(생성, 읽기, 삭제, 연결 편집)
- [ ] LexoRank 등 "순서/번호" 시스템(삽입, 중간삽입 커버)
- [ ] displayId 산출(DFS/계층 기반, 국소 넘버링 포함)
- [ ] (간단 API 혹은 데이터 export 방식) 프론트와의 데이터 연동

***

## 2️⃣ **두 번째 할 일: 좌측 탐색기(트리/리스트 뷰) 구축**

**MVP 구조/단계별:**  
- [ ] 초간단 트리/리스트:  
  - 노트 displayId + title 리스트(계층/DFS 구조 반영)
  - 클릭 시 선택/포커스(중앙뷰로 넘김)  
  - 노드간 계층(들여쓰기/구조) 명확하게 표시  
- [ ] 초기엔 read-only여도 무방,  
  - add/del/edit 등은 추후 단계별 확장

**UX Tips:**  
- 들여쓰기(레벨별), 간단 collapse/expand(계층 강조), 노트 개수/깊이 등 표시  
- 데이터가 잘 들어오는지만 바로 확인!

***

## 🔥 **실전 개발 플로우 예시**

1. **Rust(또는 백엔드)로 아래 지원**
   - `GET /notes`: DFS 구조+필수 메타로 모든 노트(1차 구현시 Array, 추후 트리 JSON 등)
   - (`POST /notes`, `DELETE /notes` 등은 차차 추가)

2. **프론트(React/TS 등)**
   - 최초엔 “노트 목록·트리 하나 그려주는 컴포넌트”만 있으면 됨
   - `useEffect` 등으로 /notes 호출 → “displayId+title”로 리스트 표시
   - 들여쓰기/level만 잘 나오면 구조정합성 바로 컨펌 가능
   - (이후엔 클릭 시 중앙 카드뷰에 노트 본문/상세 띄우는 기능 점증적 추가)

***

## 💡 **이 단계의 대표 "완료 기준"**

- "폴더-DB ingest → API → 프론트 트리" 전체 파이프라인이 한 번에 통과(노트 구조·관계·번호까지 확인 OK)
- 구조/관계/번호가 안 맞거나 깨지면 바로 탐색기에서 확인 가능
- 이후 add/edit/delete/중간삽입 등 모든 기능은 이 구조 위에 더하면 됨

***

### “이렇게 출발하면 명확한 구조와 문제발견-개선 루프가 확실히 보장”됩니다.

**실제 Rust API 기본 설계/초기 프론트 트리컴포넌트 예/데모 데이터 등도 필요하다면 바로 안내드릴 수 있습니다!**  
프론트 MVP 뼈대, Rust-API 스펙, Kuzu 쿼리 설계 등 세부 구간 요청 주세요!맞아요!  
**1순위는 “백엔드 최소기능(MVP)” 만들기**  
- 마크다운 파싱/폴더 ingest  
- 노트&관계 기본 DB 저장(+순서/번호 LexoRank)  
- 모든 노트 구조를 쿼리→JSON 하나로 전달

**2순위는 “좌측 탐색기(MVP 트리/리스트 뷰)”**  
- DB에서 넘겨받은 노트구조를  
- 좌측 패널에서 계층별(트리식) 목록+번호+타이틀로 보여줌  
- 클릭 시 카드뷰/본문(중앙)로 바로 Jump

이 두 가지가 완성되면  
→ 노트 구조/관계/번호 테스트, “실제 데이터의 흐름”을 1회에 명확히 눈으로 확인 가능  
→ 이후 단계(연결/편집/카드뷰/고급 검색…)은 모두 ‘이 구조’ 위에서 쌓아가면 돼!

**초기 설계의 핵심:**  
- “구조/순서”가 화면에서 **실제로 어떻게 나오는지**  
- **관계/넘버 갱신이 즉각 반영되는지**  
- (API→UI→테스트 루프가 빠르게 돈다는 사실!)

실제 Rust API, 초간단 트리 컴포넌트 예, MVP 데이터구조 플로우가 더 필요하면 언제든 요청하세요!  
이 순서가 실제로 가장 빠르고, 안전하고, 확장성이 좋은 방법입니다.

# 🗂️ [필수] 노트 데이터모델·KuzuDB 스키마 설계 Task 티켓

## **✔️ 0) Epic/Feature 추가: 데이터모델/DB스키마 설계 (Phase 0~1)**
“노트 구조, 관계, 넘버링 등 모든 동작의 기준이 되는  
공통 데이터 모델과 DB(특히 그래프/표형 Kuzu 스키마) 설계 작업부터 선행한다.”

### [Task-0-1]  
**노트 단위 데이터 구조(타입/필드) 설계**
- [ ] 노트 구조:  
 - persistentId(uuid), title, content, createdAt, updatedAt  
 - parentId(계층연결), rank(LexoRank), displayId(넘버/후계산),  
 - optional: filePath, tags, meta(YAML일치)
- [ ] 노트 작성/저장을 위한 구조(타입스크립트 or 러스트 Struct, YAML 구조 등) 정의  
- [ ] 프론트/백엔드가 동일 구조로 동작하도록 명확히 문서화


### [Task-0-2]  
**KuzuDB(그래프/관계) 스키마 설계**  
- [ ] 노드 타입 정하기: Note(노트 단위), Tag/Link 등(후행)  
- [ ] 필수 속성: uuid(PK), title, content, created_at, updated_at, rank, file_path 등  
- [ ] 관계 타입: :CHILD_OF, :NEXT(형제), :PARENT_OF(optional),  
  - 필요시 :TAGGED, :LINKED 등 확장 가능  
- [ ] 관계 생성 규칙/방향성(:CHILD_OF는 from=자식, to=부모. :NEXT는 from=앞, to=뒤 형제)  
- [ ] 노드/관계 인덱스: uuid, file_path, rank, parent_id 등  
- [ ] PK/복합키, 제약조건 명확히(중복방지, orphan방지 등)
- [ ] 스키마 문서 자체(.sql/.ktable/schema.rs 등) 코드로 남길것


### [Task-0-3]  
**“DisplayId 산출/저장 정책” 설계 (초기 MVP 기준)**
- [ ] displayId(넘버)는 DB/파일 어디에 어떻게 기록/관리할지 명확히  
- [ ] LexoRank(문자열)를 저장하고, 
 넘버는 “조회 시 DFS/계층순 트래버스 – 후산출 or 부분 캐시”  
- [ ] 국소 캐시/후처리/역검색? 등 처리 정책 정리


### [Task-0-4]  
**프론트와의 데이터교환(JSON/API/Struct 등 명세 정의)**
- [ ] 노트 반환시 전달 구조(필드/계층), displayId 포함여부
- [ ] 트리? 평면Array+parentId? 간단 구조로 먼저 정하고, 명세화


## ✏️ **각각의 Task 결과물은 어때야 하는가?**
- 표/코드혹은 schema.sql/schema.rs/md,  
- 필드명/타입/의미 설명(미니주석),  
- 관계(그래프 DB의 엣지 방향·특성),  
- displayId(LexoRank) 활용 규칙,  
- 예시 데이터(샘플 한두 row)  


## 🚨 **이 작업(데이터 구조/DB스키마 설계)이 실제 "첫 노트 작성"보다 반드시 먼저!**
- DB스키마→Struct 정의→파일 포맷→API 구조→프론트→UI  
이 순서가 되어야, 코드간 불일치/버그/이상 현상 방지


## **예시: Note 데이터 타입 / Kuzu 스키마 Table/Graph 정의**

**Rust Struct 예시**
```rust
pub struct Note {
    pub uuid: String,
    pub title: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub rank: String,           // LexoRank
    pub parent_uuid: Option<String>, // DFS 계층
    pub file_path: String,
    // tag, meta, 등은 추후 확장
}
```

**Kuzu 그래프 예시(노드/관계)**
```sql
CREATE NODE TABLE Note (
    uuid STRING PRIMARY KEY,
    title STRING,
    content STRING,
    created_at DATETIME,
    updated_at DATETIME,
    rank STRING,
    parent_uuid STRING,
    file_path STRING
);

CREATE REL TABLE ChildOf (
    FROM Note TO Note
);

CREATE REL TABLE Next (
    FROM Note TO Note
);

/* 추가 인덱스/제약조건 */
CREATE INDEX ON Note(parent_uuid);
CREATE INDEX ON Note(rank);
```

**프론트 전달 JSON 예시**
```json
{
  "uuid": "xyz123",
  "title": "루만 시작",
  "content": "이것이 첫 노트입니다.",
  "createdAt": "2025-08-24T04:21:00Z",
  "updatedAt": "2025-08-24T04:21:00Z",
  "rank": "U",
  "parentUuid": null,
  "displayId": "1",
  "filePath": "/Users/xx/Notes/xyz123.md"
}
```


## ✨ [Task-0] 데이터모델/스키마 설계 Epic이 반드시 가장 첫 단계로 명세/식별되어야 하며,  
1번 티켓으로 등록, 이후 모든 개발 Task는 이 타입/스키마에 맞춰야 합니다!


추가로,  
- 상기 스키마의 상세 필드/관계/구조  
- Rust/Kuzu 쿼리 예시  
- API/프론트 전달구조  
더 자세하게 쪼개서 안내 필요하시면 말씀해 주세요!  
**이 단계가 노트작성+저장+관계/트리 뷰 전체의 기반입니다.**

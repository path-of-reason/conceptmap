# 🟦 KuzuDB 쿼리/트래버스 예시

***

## 1. 노트(노드) 생성/생성 쿼리

```sql
-- 노트(루트) 생성
CREATE (n:Note {
  uuid: "a1b2c3d4",
  title: "제텔카스텐 시작",
  content: "이것은 첫 루만식 노트입니다.",
  created_at: datetime("2025-08-24T04:20:00Z"),
  updated_at: datetime("2025-08-24T04:21:15Z"),
  rank: "U",
  parent_uuid: null,
  file_path: "/Users/xx/Notes/a1b2c3d4.md"
});
```

***

## 2. 관계(엣지) 생성

```sql
-- 자식노트 생성 + CHILD_OF 관계
CREATE (c:Note {
  uuid: "b1c2d3e4",
  title: "루만 2번노트",
  content: "이건 두번째입니다.",
  created_at: datetime("2025-08-24T04:22:00Z"),
  updated_at: datetime("2025-08-24T04:22:05Z"),
  rank: "V",
  parent_uuid: "a1b2c3d4",
  file_path: "/Users/xx/Notes/b1c2d3e4.md"
});

MATCH (n:Note {uuid: "a1b2c3d4"}), (c:Note {uuid: "b1c2d3e4"})
CREATE (c)-[:CHILD_OF]->(n);
```

```sql
-- NEXT (형제간 순서연결) 생성
MATCH (a:Note {uuid: "b1c2d3e4"}), (b:Note {uuid: "c3d4e5f6"})
CREATE (a)-[:NEXT]->(b);
```

***

## 3. 특정 노트(루트 레벨) 전체 트리 반환 (DFS 순)

**DFS를 간단하게 트리 전체로 뽑으려면 (1~2레벨만 MVP):**

```sql
-- 루트노트 리스트
MATCH (n:Note)
WHERE n.parent_uuid IS NULL
RETURN n
ORDER BY n.rank;

-- 루트 자식들
MATCH (p:Note)-[:CHILD_OF]->(c:Note)
WHERE p.parent_uuid IS NULL
RETURN p.title AS parent, c.title, c.rank
ORDER BY p.rank, c.rank;
```

**임의 노트의 전체 후손(서브트리) - DFS 순회(재귀적 쿼리)**
```sql
-- Kuzu에서 재귀 패턴은 WITH RECURSIVE (혹은 Cypher의 variable length)
WITH RECURSIVE descendants(uuid, title, rank, parent_uuid, level) AS (
  SELECT uuid, title, rank, parent_uuid, 0 FROM Note WHERE uuid = $root_uuid
  UNION ALL
  SELECT n.uuid, n.title, n.rank, n.parent_uuid, d.level + 1
  FROM Note n
  JOIN descendants d ON n.parent_uuid = d.uuid
)
SELECT * FROM descendants
ORDER BY level, rank;
```
*($root_uuid 부분에 루트 노트 uuid를 바꿔 넘김)*

***

## 4. displayId(계층 넘버) 계산 예시(Rust or API)

**Rust 스타일, 루트부터 DFS 순회**

```rust
fn assign_display_ids(root_notes: Vec<Note>, notes_map: &HashMap<String, Note>) -> HashMap<String, String> {
    let mut result = HashMap::new();
    for (i, root) in root_notes.iter().enumerate() {
        let mut stack = vec![(root, vec![(i + 1)])]; // displayId ["1"], ["2"], ...
        while let Some((note, prefix)) = stack.pop() {
            let disp = prefix.iter().map(ToString::to_string).collect::<Vec<_>>().join(".");
            result.insert(note.uuid.clone(), disp.clone());
            let mut children: Vec<&Note> = notes_map.values()
                .filter(|n| n.parent_uuid == Some(note.uuid.clone()))
                .collect();
            children.sort_by_key(|c| c.rank.clone());
            for (j, child) in children.iter().enumerate().rev() {
                let mut child_prefix = prefix.clone();
                child_prefix.push(j + 1);
                stack.push((child, child_prefix));
            }
        }
    }
    result
}
```
- 노트 uuid → displayId("1.2.1" 등) 맵 생성
- 프론트/백엔드 통일 구조

***

## 5. 프론트 노드(트리) 렌더용 API 응답 JSON

```json
[
  {
    "uuid": "a1b2c3d4",
    "title": "노트1",
    "displayId": "1",
    "children": [
      {
        "uuid": "b1c2d3e4",
        "title": "노트2",
        "displayId": "1.1",
        "children": [ ... ]
      }
    ]
  },
  {
    "uuid": "c1d2e3f4",
    "title": "노트3",
    "displayId": "2",
    "children": []
  }
]
```

***

## 6. 노드/관계 탐색 주요 쿼리

- **특정 노드의 부모 찾기**
    ```sql
    MATCH (n:Note {uuid: $uuid})-[:CHILD_OF]->(p:Note) RETURN p;
    ```
- **형제(동일 parent의 다른 노트) 찾기**
    ```sql
    MATCH (n:Note)-[:CHILD_OF]->(p:Note)<-[:CHILD_OF]-(sibling:Note)
    WHERE n.uuid = $uuid AND sibling.uuid <> $uuid
    RETURN sibling
    ORDER BY sibling.rank;
    ```
- **자식 노트(하위 1단계)**
    ```sql
    MATCH (p:Note {uuid: $uuid})<-[:CHILD_OF]-(c:Note)
    RETURN c ORDER BY c.rank;
    ```
- **DFS로 단일 노트~리프까지 연결경로 쿼리**  
    (재귀 WITH RECURSIVE 참고)

***

## 7. 기타
- **삭제**
    - 노트 삭제 시 하위/관계(ChildOf/Next 등)도 연쇄적으로 삭제하도록 컨트롤 필요

- **중간삽입/순서변경**
    - rank(LexoRank) 조정, Next 관계 업데이트

***

## ⬇️ 참고: 노트 YAML (파일) 예

```markdown
---
uuid: "a1b2c3d4"
title: "제텔카스텐 시작"
created_at: "2025-08-24T04:20:00Z"
updated_at: "2025-08-24T04:21:15Z"
parent_uuid: null
rank: "U"
---

이것은 첫 루만식 노트입니다.
```

***

이 예시들을 실전 기반으로  
- Rust(Tauri) 쿼리 코드,  
- 프론트 리스트/카드뷰 예시,  
- 관계연산(중간삽입, 이동, 삭제 등),  
- 고급 쿼리(검색, DFS 트래버스 등)  
까지 구체적으로 추가 안내 가능합니다.  
필요 시 요청 구간 말씀해 주세요!

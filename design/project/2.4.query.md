# ğŸŸ¦ KuzuDB ì¿¼ë¦¬/íŠ¸ë˜ë²„ìŠ¤ ì˜ˆì‹œ

***

## 1. ë…¸íŠ¸(ë…¸ë“œ) ìƒì„±/ìƒì„± ì¿¼ë¦¬

```sql
-- ë…¸íŠ¸(ë£¨íŠ¸) ìƒì„±
CREATE (n:Note {
  uuid: "a1b2c3d4",
  title: "ì œí…”ì¹´ìŠ¤í… ì‹œì‘",
  content: "ì´ê²ƒì€ ì²« ë£¨ë§Œì‹ ë…¸íŠ¸ì…ë‹ˆë‹¤.",
  created_at: datetime("2025-08-24T04:20:00Z"),
  updated_at: datetime("2025-08-24T04:21:15Z"),
  rank: "U",
  parent_uuid: null,
  file_path: "/Users/xx/Notes/a1b2c3d4.md"
});
```

***

## 2. ê´€ê³„(ì—£ì§€) ìƒì„±

```sql
-- ìì‹ë…¸íŠ¸ ìƒì„± + CHILD_OF ê´€ê³„
CREATE (c:Note {
  uuid: "b1c2d3e4",
  title: "ë£¨ë§Œ 2ë²ˆë…¸íŠ¸",
  content: "ì´ê±´ ë‘ë²ˆì§¸ì…ë‹ˆë‹¤.",
  created_at: datetime("2025-08-24T04:22:00Z"),
  updated_at: datetime("2025-08-24T04:22:05Z"),
  rank: "V",
  parent_uuid: "a1b2c3d4",
  file_path: "/Users/xx/Notes/b1c2d3e4.md"
});

MATCH (n:Note {uuid: "a1b2c3d4"}), (c:Note {uuid: "b1c2d3e4"})
CREATE (c)-[:CHILD_OF]->(n);
```

```sql
-- NEXT (í˜•ì œê°„ ìˆœì„œì—°ê²°) ìƒì„±
MATCH (a:Note {uuid: "b1c2d3e4"}), (b:Note {uuid: "c3d4e5f6"})
CREATE (a)-[:NEXT]->(b);
```

***

## 3. íŠ¹ì • ë…¸íŠ¸(ë£¨íŠ¸ ë ˆë²¨) ì „ì²´ íŠ¸ë¦¬ ë°˜í™˜ (DFS ìˆœ)

**DFSë¥¼ ê°„ë‹¨í•˜ê²Œ íŠ¸ë¦¬ ì „ì²´ë¡œ ë½‘ìœ¼ë ¤ë©´ (1~2ë ˆë²¨ë§Œ MVP):**

```sql
-- ë£¨íŠ¸ë…¸íŠ¸ ë¦¬ìŠ¤íŠ¸
MATCH (n:Note)
WHERE n.parent_uuid IS NULL
RETURN n
ORDER BY n.rank;

-- ë£¨íŠ¸ ìì‹ë“¤
MATCH (p:Note)-[:CHILD_OF]->(c:Note)
WHERE p.parent_uuid IS NULL
RETURN p.title AS parent, c.title, c.rank
ORDER BY p.rank, c.rank;
```

**ì„ì˜ ë…¸íŠ¸ì˜ ì „ì²´ í›„ì†(ì„œë¸ŒíŠ¸ë¦¬) - DFS ìˆœíšŒ(ì¬ê·€ì  ì¿¼ë¦¬)**
```sql
-- Kuzuì—ì„œ ì¬ê·€ íŒ¨í„´ì€ WITH RECURSIVE (í˜¹ì€ Cypherì˜ variable length)
WITH RECURSIVE descendants(uuid, title, rank, parent_uuid, level) AS (
  SELECT uuid, title, rank, parent_uuid, 0 FROM Note WHERE uuid = $root_uuid
  UNION ALL
  SELECT n.uuid, n.title, n.rank, n.parent_uuid, d.level + 1
  FROM Note n
  JOIN descendants d ON n.parent_uuid = d.uuid
)
SELECT * FROM descendants
ORDER BY level, rank;
```
*($root_uuid ë¶€ë¶„ì— ë£¨íŠ¸ ë…¸íŠ¸ uuidë¥¼ ë°”ê¿” ë„˜ê¹€)*

***

## 4. displayId(ê³„ì¸µ ë„˜ë²„) ê³„ì‚° ì˜ˆì‹œ(Rust or API)

**Rust ìŠ¤íƒ€ì¼, ë£¨íŠ¸ë¶€í„° DFS ìˆœíšŒ**

```rust
fn assign_display_ids(root_notes: Vec<Note>, notes_map: &HashMap<String, Note>) -> HashMap<String, String> {
    let mut result = HashMap::new();
    for (i, root) in root_notes.iter().enumerate() {
        let mut stack = vec![(root, vec![(i + 1)])]; // displayId ["1"], ["2"], ...
        while let Some((note, prefix)) = stack.pop() {
            let disp = prefix.iter().map(ToString::to_string).collect::<Vec<_>>().join(".");
            result.insert(note.uuid.clone(), disp.clone());
            let mut children: Vec<&Note> = notes_map.values()
                .filter(|n| n.parent_uuid == Some(note.uuid.clone()))
                .collect();
            children.sort_by_key(|c| c.rank.clone());
            for (j, child) in children.iter().enumerate().rev() {
                let mut child_prefix = prefix.clone();
                child_prefix.push(j + 1);
                stack.push((child, child_prefix));
            }
        }
    }
    result
}
```
- ë…¸íŠ¸ uuid â†’ displayId("1.2.1" ë“±) ë§µ ìƒì„±
- í”„ë¡ íŠ¸/ë°±ì—”ë“œ í†µì¼ êµ¬ì¡°

***

## 5. í”„ë¡ íŠ¸ ë…¸ë“œ(íŠ¸ë¦¬) ë Œë”ìš© API ì‘ë‹µ JSON

```json
[
  {
    "uuid": "a1b2c3d4",
    "title": "ë…¸íŠ¸1",
    "displayId": "1",
    "children": [
      {
        "uuid": "b1c2d3e4",
        "title": "ë…¸íŠ¸2",
        "displayId": "1.1",
        "children": [ ... ]
      }
    ]
  },
  {
    "uuid": "c1d2e3f4",
    "title": "ë…¸íŠ¸3",
    "displayId": "2",
    "children": []
  }
]
```

***

## 6. ë…¸ë“œ/ê´€ê³„ íƒìƒ‰ ì£¼ìš” ì¿¼ë¦¬

- **íŠ¹ì • ë…¸ë“œì˜ ë¶€ëª¨ ì°¾ê¸°**
    ```sql
    MATCH (n:Note {uuid: $uuid})-[:CHILD_OF]->(p:Note) RETURN p;
    ```
- **í˜•ì œ(ë™ì¼ parentì˜ ë‹¤ë¥¸ ë…¸íŠ¸) ì°¾ê¸°**
    ```sql
    MATCH (n:Note)-[:CHILD_OF]->(p:Note)<-[:CHILD_OF]-(sibling:Note)
    WHERE n.uuid = $uuid AND sibling.uuid <> $uuid
    RETURN sibling
    ORDER BY sibling.rank;
    ```
- **ìì‹ ë…¸íŠ¸(í•˜ìœ„ 1ë‹¨ê³„)**
    ```sql
    MATCH (p:Note {uuid: $uuid})<-[:CHILD_OF]-(c:Note)
    RETURN c ORDER BY c.rank;
    ```
- **DFSë¡œ ë‹¨ì¼ ë…¸íŠ¸~ë¦¬í”„ê¹Œì§€ ì—°ê²°ê²½ë¡œ ì¿¼ë¦¬**  
    (ì¬ê·€ WITH RECURSIVE ì°¸ê³ )

***

## 7. ê¸°íƒ€
- **ì‚­ì œ**
    - ë…¸íŠ¸ ì‚­ì œ ì‹œ í•˜ìœ„/ê´€ê³„(ChildOf/Next ë“±)ë„ ì—°ì‡„ì ìœ¼ë¡œ ì‚­ì œí•˜ë„ë¡ ì»¨íŠ¸ë¡¤ í•„ìš”

- **ì¤‘ê°„ì‚½ì…/ìˆœì„œë³€ê²½**
    - rank(LexoRank) ì¡°ì •, Next ê´€ê³„ ì—…ë°ì´íŠ¸

***

## â¬‡ï¸ ì°¸ê³ : ë…¸íŠ¸ YAML (íŒŒì¼) ì˜ˆ

```markdown
---
uuid: "a1b2c3d4"
title: "ì œí…”ì¹´ìŠ¤í… ì‹œì‘"
created_at: "2025-08-24T04:20:00Z"
updated_at: "2025-08-24T04:21:15Z"
parent_uuid: null
rank: "U"
---

ì´ê²ƒì€ ì²« ë£¨ë§Œì‹ ë…¸íŠ¸ì…ë‹ˆë‹¤.
```

***

ì´ ì˜ˆì‹œë“¤ì„ ì‹¤ì „ ê¸°ë°˜ìœ¼ë¡œ  
- Rust(Tauri) ì¿¼ë¦¬ ì½”ë“œ,  
- í”„ë¡ íŠ¸ ë¦¬ìŠ¤íŠ¸/ì¹´ë“œë·° ì˜ˆì‹œ,  
- ê´€ê³„ì—°ì‚°(ì¤‘ê°„ì‚½ì…, ì´ë™, ì‚­ì œ ë“±),  
- ê³ ê¸‰ ì¿¼ë¦¬(ê²€ìƒ‰, DFS íŠ¸ë˜ë²„ìŠ¤ ë“±)  
ê¹Œì§€ êµ¬ì²´ì ìœ¼ë¡œ ì¶”ê°€ ì•ˆë‚´ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
í•„ìš” ì‹œ ìš”ì²­ êµ¬ê°„ ë§ì”€í•´ ì£¼ì„¸ìš”!
